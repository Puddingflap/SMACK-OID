<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Smackoid</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    :root{ color-scheme: dark light; }
    html,body{margin:0;padding:0;background:#070b14;color:#e8f0ff;font-family:system-ui,Segoe UI,Inter,Arial,sans-serif;height:100%}
    /* iOS friendly fullscreen */
    body{min-height:100svh}
    #gameCanvas{position:relative;width:100vw;height:100svh;touch-action:none}
    .hud{
      position:fixed; top:calc(env(safe-area-inset-top) + 12px); left:calc(env(safe-area-inset-left) + 12px);
      background:rgba(10,14,24,.7); border:1px solid rgba(255,255,255,.1); border-radius:12px; padding:10px 14px; backdrop-filter: blur(6px);
      z-index:10
    }
    .hud h3{margin:0 0 6px 0; font-size:14px; color:#cfe6ff}
    .row{display:flex;gap:18px;align-items:center;flex-wrap:wrap}
    .label{font-size:13px;color:#c7d3ee}
    .value{font-weight:800}
    .muted{color:#90a0c0; font-size:12px; margin-top:4px}
    .centerNote{
      position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
      padding:10px 14px; border-radius:12px; border:1px solid rgba(255,255,255,.1);
      background:rgba(10,14,24,.65); color:#e8f0ff; font-weight:700; display:none; z-index:10
    }
  </style>
</head>
<body>
  <div id="gameCanvas"></div>
  <div class="hud">
    <h3>Smackoid</h3>
    <div class="row">
      <div class="label">Mcap $:</div><div id="mcap" class="value">0 B</div>
      <div class="label">Distance:</div><div id="dist" class="value">0 m</div>
      <div class="label">Best:</div><div id="best" class="value">0 m</div>
    </div>
    <div class="muted">Desktop: hold <b>SPACE</b> to charge, <b>release</b> to hit. • Mobile: <b>press & hold</b>, then <b>release</b>.</div>
  </div>
  <!-- Image fallback for the asteroid -->
  <img id="sprite" src="assets/cz-droid.png" alt="" style="display:none" />
  <div id="centerMsg" class="centerNote"></div>

<script>
/* ================= Responsive, time-based Smackoid ================= */
let asteroidImg=null, p5Ready=false;
let htmlImg=null, htmlReady=false;

/** World & responsive sizing (updated on resize) **/
let GROUND_Y;
let ASTEROID_R;
let BATTER_X;
const HIT_OFFSET_PCT = 0.09; // 9% of width to the right of batter
let HIT_OFFSET;

function recalcLayout(){
  // Ground ~82% down the screen; radius scales with height
  GROUND_Y  = Math.round(height * 0.78);
  ASTEROID_R = Math.round(height * 0.115);  // ~13% screen height
  BATTER_X = Math.round(width * 0.16);
  HIT_OFFSET = Math.round(width * HIT_OFFSET_PCT);
  // Update entities
  asteroid.r = ASTEROID_R;
  batter.x = BATTER_X;
  batter.y = GROUND_Y - Math.round(height * 0.033);
}

/** Physics constants in real units (per second) **/
let GRAVITY = 0.55;        // px/s² (base; portrait tuning below)
let DRAG_COEFF = 0.0012;   // air drag (per px of speed)
let WIND_BASE = 0.0006;    // px/s²
let wind = 0;

// Launch easing window (seconds)
const LAUNCH_TIME = 0.6;
const LAUNCH_G_SCALE = 0.8;
const LAUNCH_D_SCALE = 0.45;

// Sweet spot window relative to ground (scales with screen)
let SWEET_CENTER_Y; // set in draw from GROUND_Y
let SWEET_HALF;     // set in draw

/** Camera **/
let camX = 0;
const CAM_LEAD = 0.35;
const CAM_EASE = 0.08;
let camShake = 0, camShakeT = 0;

/** State **/
let phase='drop';
let asteroid={ x: 0, y:-150, vx:0, vy:0, r:70 };
let batter={ x: 0, y: 0, swingT:0, swinging:false };
const SWING_START = -Math.PI*0.60, SWING_IMPACT_T=0.35, SWING_END = -Math.PI*0.15;
function armAngle(){ return lerp(SWING_START, SWING_END, batter.swinging ? constrain(batter.swingT,0,1) : 0); }

/** Score **/
let distance=0, bestDistance=0, mcap=0;

/** Power **/
let charging=false, charge=0, chargeDir=1;
const CHARGE_SPEED = 0.028;

/** Impact planning **/
let pendingHit=false, plannedV=null, locked=false;
let flightTime=0;       // seconds since impact

/** UI helpers **/
const centerMsgEl = document.getElementById('centerMsg');
const showCenter = (msg)=>{ centerMsgEl.textContent=msg; centerMsgEl.style.display='block'; };
const hideCenter = ()=>{ centerMsgEl.style.display='none'; };

/** Portrait vs Landscape tuning **/
function applyOrientationTuning(){
  const portrait = height > width;
  if (portrait){
    // On phones in portrait, things feel faster due to fewer pixels across,
    // so tone down gravity a bit and drop speed a touch for fairness.
    GRAVITY   = 0.50;
    DRAG_COEFF= 0.0011;
  } else {
    GRAVITY   = 0.55;
    DRAG_COEFF= 0.0012;
  }
}

/** p5 setup **/
function setup(){
  const cnv=createCanvas(windowWidth, windowHeight);
  cnv.parent('gameCanvas');
  imageMode(CENTER); textFont('system-ui');

  // Load image with fallback
  loadImage('assets/cz-droid.png', img => { asteroidImg=img; p5Ready=true; });
  htmlImg = document.getElementById('sprite');
  if (htmlImg.complete && htmlImg.naturalWidth>0) htmlReady = true;
  htmlImg.addEventListener('load', ()=>{ htmlReady=true; });

  applyOrientationTuning();
  recalcLayout();
  resetRound(false);

  // Keyboard
  addEventListener('keydown', e => { if(e.code==='Space'){ e.preventDefault(); handlePress(); } }, {passive:false});
  addEventListener('keyup',   e => { if(e.code==='Space'){ e.preventDefault(); handleRelease(); } }, {passive:false});

  // Touch (iOS/Android)
  addEventListener('touchstart', e => { e.preventDefault(); handlePress(); }, {passive:false});
  addEventListener('touchend',   e => { e.preventDefault(); handleRelease(); }, {passive:false});
}

/** Resize **/
function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  applyOrientationTuning();
  recalcLayout();
}

/** Input handlers **/
function handlePress(){
  if (phase==='end'){ resetRound(true); return; }
  if (!locked && !charging && (phase==='drop' || phase==='charge')){
    charging=true; phase='charge';
  }
}
function handleRelease(){
  if (phase==='end'){ resetRound(true); return; }
  if (!locked && charging){
    charging=false; locked=true;
    decideImpact();
    phase='swing'; batter.swinging=true; batter.swingT=0;
  }
}

/** Main loop (time-based) **/
function draw(){
  clear();

  // Orientation-based sweet spot (scales with screen height)
  SWEET_CENTER_Y = GROUND_Y - Math.round(height * 0.15);
  SWEET_HALF     = Math.round(height * 0.055);

  // delta time in seconds (clamped to avoid spikes on tab switches)
  const dt = Math.min(0.033, Math.max(0.0, deltaTime / 1000)); // ~33 ms cap

  // Camera shake decay
  let shakeX=0;
  if (camShake > 0){
    camShakeT += 0.3;
    shakeX = Math.sin(camShakeT*12) * camShake;
    camShake = lerp(camShake, 0, 0.18);
    if (camShake < 0.05) camShake = 0;
  }

  // Camera follow
  if (phase==='flight' || phase==='swing'){
    const target = asteroid.x - width*CAM_LEAD;
    camX += (target - camX) * (1 - Math.pow(1 - CAM_EASE, dt*60)); // dt sensitive easing
  } else {
    camX += (0 - camX) * (1 - Math.pow(1 - CAM_EASE, dt*60));
  }

  drawHorizon(shakeX);
  drawBatter(shakeX);

  // HUD
  byId('mcap').textContent  = `${mcap.toFixed(1)} B`;
  byId('dist').textContent  = `${Math.floor(distance)} m`;
  byId('best').textContent  = `${Math.floor(bestDistance)} m`;

  // Charge ping-pong (dt aware)
  if ((phase==='drop' || phase==='charge') && charging){
    phase='charge';
    const step = CHARGE_SPEED * dt * 60; // keep similar feel across FPS
    charge += step * chargeDir;
    if (charge>=1){ charge=1; chargeDir=-1; }
    if (charge<=0){ charge=0; chargeDir=1; }
  }

  if(phase==='drop' || phase==='charge'){
    // Drop speed in px/s, scaled by dt; tuned per orientation in applyOrientationTuning if needed
    const PORTRAIT = height > width;
    const DROP_SPEED = PORTRAIT ? 380 : 450; // px per second
    asteroid.y += DROP_SPEED * dt;

    if (asteroid.y >= GROUND_Y - asteroid.r){
      asteroid.y = GROUND_Y - asteroid.r;
      phase='end'; showCenter('Restart? Press SPACE or Tap'); bestDistance=Math.max(bestDistance,distance);
    }
    drawAsteroid(shakeX);
  }
  else if(phase==='swing'){
    if (pendingHit && batter.swingT >= SWING_IMPACT_T){
      asteroid.vx = plannedV.vx; asteroid.vy = plannedV.vy;
      pendingHit=false; plannedV=null;
      flightTime=0;
      camShake = 6; camShakeT = 0;
    }
    drawAsteroid(shakeX);
    // swing anim tweaked with dt for consistency
    batter.swingT += 0.20 * dt * 60;
    if (batter.swingT >= 1){
      batter.swingT=0; batter.swinging=false;
      phase = (Math.abs(asteroid.vx)+Math.abs(asteroid.vy) > 0.001) ? 'flight' : 'drop';
    }
  }
  else if(phase==='flight'){
    // Launch easing for first LAUNCH_TIME seconds
    const launchPhase = flightTime < LAUNCH_TIME;
    const g = launchPhase ? GRAVITY * LAUNCH_G_SCALE : GRAVITY;
    const dragCoeff = launchPhase ? DRAG_COEFF * LAUNCH_D_SCALE : DRAG_COEFF;

    // Air drag (quadratic-ish)
    const v = Math.hypot(asteroid.vx, asteroid.vy);
    const drag = dragCoeff * v;
    asteroid.vx -= (drag * asteroid.vx) * dt * 60;
    asteroid.vy -= (drag * asteroid.vy) * dt * 60;

    // Wind & gravity, dt based
    asteroid.vx += wind * dt * 60;
    asteroid.vy += g    * dt * 60;

    // Integrate position
    asteroid.x += asteroid.vx * dt * 60;
    asteroid.y += asteroid.vy * dt * 60;

    drawAsteroid(shakeX);

    distance = Math.max(distance, asteroid.x - (BATTER_X + HIT_OFFSET));
    mcap = Math.max(0, distance/25);

    if(asteroid.y >= GROUND_Y - asteroid.r){
      asteroid.y = GROUND_Y - asteroid.r;
      phase='end'; showCenter('Restart? Press SPACE or Tap'); bestDistance=Math.max(bestDistance,distance);
    }

    flightTime += dt;
  }
  else if(phase==='end'){
    drawAsteroid(shakeX);
  }

  drawPowerMeter();
}

/** Impact decision **/
function decideImpact(){
  const dy = asteroid.y - (GROUND_Y - Math.round(height*0.15));
  const within = Math.abs(dy) <= Math.round(height*0.055);
  if (!within){ pendingHit=false; plannedV=null; return; }

  const q = 1 - Math.min(1, Math.abs(dy)/Math.round(height*0.055));
  const curved = Math.pow(charge, 1.2);

  // px/s initial speed
  let baseStrength = 18 + curved*(42-18);
  baseStrength *= (0.75 + 0.40*q);
  if (Math.abs(dy) <= Math.round(height*0.055)*0.20) baseStrength *= 1.35;

  const angle = radians(26 + 36*q);
  plannedV = { vx: Math.cos(angle)*baseStrength, vy: -Math.sin(angle)*baseStrength };
  pendingHit = true;

  // small wind variance
  if (Math.random() < 0.5) wind = (Math.random()*2-1) * WIND_BASE;
}

/** Reset **/
function resetRound(newWind=true){
  hideCenter();
  phase='drop';
  asteroid.x = BATTER_X + HIT_OFFSET;
  asteroid.y = -ASTEROID_R * 2;
  asteroid.vx = asteroid.vy = 0;
  distance = 0; mcap = 0;
  wind = newWind ? (Math.random()*2-1) * WIND_BASE : 0;
  charge = 0; chargeDir = 1; charging = false;
  pendingHit=false; plannedV=null; locked=false;
  camX = 0; camShake=0; camShakeT=0;
  flightTime=0;
}

/** Drawing **/
function drawAsteroid(shakeX=0){
  const sx = (asteroid.x - camX) + shakeX;
  if(p5Ready && asteroidImg){
    image(asteroidImg, sx, asteroid.y, asteroid.r*2, asteroid.r*2);
  } else if (htmlReady && htmlImg){
    const ctx = drawingContext;
    ctx.save(); ctx.imageSmoothingEnabled = true;
    ctx.drawImage(htmlImg, sx - asteroid.r, asteroid.y - asteroid.r, asteroid.r*2, asteroid.r*2);
    ctx.restore();
  } else {
    noStroke(); fill(180); circle(sx, asteroid.y, asteroid.r*2);
  }
}

function drawHorizon(shakeX=0){
  const start = -100000 - camX + shakeX;
  const w = 200000 + width;
  noStroke(); fill(20,30,50);
  rect(start, GROUND_Y, w, height-GROUND_Y);
  stroke(80,120,200,120);
  line(start, GROUND_Y, start+w, GROUND_Y);
}

function drawPowerMeter(){
  // Scale HUD a bit on tiny phones
  const scaleHUD = Math.max(0.85, Math.min(1, width/390));
  const w = 260 * scaleHUD, h = 14 * scaleHUD, x = width - w - 20, y = 20 + (window.visualViewport?.offsetTop || 0);
  noFill(); stroke(255,80); rect(x,y,w,h,8*scaleHUD);
  const p = (phase==='charge' && (charge>0 || charging)) ? charge : 0;
  noStroke(); fill(110,231,255,180);
  rect(x+2,y+2,(w-4)*p,h-4,6*scaleHUD);
  fill(200); textSize(12*scaleHUD); textAlign(LEFT,TOP); text('Power',x,y+h+4);
}

function drawBatter(shakeX=0){
  const sx = (batter.x - camX) + shakeX;
  if (sx < -60 || sx > width+60) return;
  push(); translate(sx,batter.y);
  stroke(220); strokeWeight(4);
  line(0,0,-10,20); line(0,0,10,20);
  line(0,-20,0,0);
  noStroke(); fill(240); circle(0,-28,14);
  stroke(220); strokeWeight(4);
  const a = armAngle();
  const handX = 0 + Math.cos(a)*22, handY = -12 + Math.sin(a)*22;
  line(0,-12, handX, handY);
  line(0,-12, -16, -6);
  stroke(255,210,120); strokeWeight(6);
  line(handX, handY, handX + Math.cos(a)*26, handY + Math.sin(a)*26);
  pop();
}

function byId(id){ return document.getElementById(id); }
</script>
</body>
</html>
